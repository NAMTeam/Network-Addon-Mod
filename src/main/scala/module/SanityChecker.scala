package com.sc4nam.module

import java.nio.file.{Files, Paths, Path}
import resource._
import io.github.memo33.metarules.meta.{RotFlip, Rule, EquivRule, IdTile}
import syntax.IdTile
import Rul2Model.{iterateRulFiles, parseRule}

/** Run with `sbt "runMain com.sc4nam.module.SanityChecker"`.
  */
object SanityChecker {

  val linePatternIncludingNewlines = "(?<=\n|\r(?!\n))"

  def main(args: Array[String]): Unit = {
    checkRedundantRul2()
  }

  /** Scans the Controller/RUL2/ folder for handwritten RUL2 code that is
    * superseded by metarule code.
    *
    * The respective lines are commented out and tagged as "; metaruled".
    *
    * Make sure all your changes to files are committed to git beforehand,
    * as this modifies files in place.
    *
    * Afterwards, you need to manually look through the changes and remove the
    * redundant code.
    */
  def checkRedundantRul2(): Unit = {
    val seen = collection.mutable.Set.empty[EquivRule]

    // first cache all the RUL2 code generated by metarules
    LOGGER.info("caching RUL2 code generated by metarules")
    iterateRulFiles(Paths.get("target")).foreach { path =>
      if (isMetaruleFile(path)) {
        for (scanner <- managed(new java.util.Scanner(path.toFile(), "UTF-8"))) {
          while(scanner.hasNextLine()) {
            parseRule(scanner.nextLine()).foreach { rule =>
              seen.add(new EquivRule(rule))
            }
          }
        }
      }
    }

    // then check handwritten RUL2 code for redundancies
    LOGGER.info("searching for redundant handwritten RUL2 code")
    iterateRulFiles(Paths.get("Controller/RUL2")).foreach { path =>
      if (!isMetaruleFile(path)) {
        val tmpPath = path.resolveSibling(path.getFileName().toString() + ".tmp")
        val endsWithNewline = fileEndsWithNewline(path)  // attempt to preserve missing newlines at end of files to avoid noise
        scala.util.Using.resources(
          new java.util.Scanner(path.toFile(), "UTF-8").useDelimiter(linePatternIncludingNewlines),
          new java.io.PrintWriter(tmpPath.toFile(), "UTF-8")
        ) { (lineScanner, printer) =>
          while (lineScanner.hasNext()) {
            val line = lineScanner.next()
            if (parseRule(line).exists(rule => seen(new EquivRule(rule)))) {
              printer.println(s";${line.stripLineEnd}; metaruled")  // comments out the line
            } else {
              printer.print(line)  // preserving original linebreaks
            }
          }
        }
        Files.move(tmpPath, path, java.nio.file.StandardCopyOption.REPLACE_EXISTING)
      }
    }
  }

  // Choose here the metarule-generated code that the handwritten RUL2 code
  // should be compared to.
  val metaruleFiles = Set("Sec7h0_OnslopeMetaGenerated_MANAGED.txt")

  def isMetaruleFile(path: Path): Boolean = {
    metaruleFiles.contains(path.getFileName().toString())
  }

  def fileEndsWithNewline(path: Path): Boolean = {
    managed(new java.io.RandomAccessFile(path.toFile(), "r")) acquireAndGet { raf =>
      val size = Files.size(path)
      if (size > 0) {
        raf.seek(size - 1)
        val bytes = Array[Byte](0)
        raf.read(bytes)
        bytes(0) == 0x0a || bytes(0) == 0x0d  // last byte matches \n or \r (assuming last character is ASCII)
      } else {  // size == 0
        false
      }
    }
  }
}
