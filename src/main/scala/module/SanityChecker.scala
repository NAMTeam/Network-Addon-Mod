package com.sc4nam.module

import java.nio.file.{Files, Paths, Path}
import resource._
import io.github.memo33.metarules.meta.{RotFlip, Rule, EquivRule, IdTile}
import syntax.IdTile

/** Run with `sbt "runMain com.sc4nam.module.SanityChecker"`.
  */
object SanityChecker {

  def main(args: Array[String]): Unit = {
    checkRedundantRul2()
  }

  /** Scans the Controller/RUL2/ folder for handwritten RUL2 code that is
    * superseded by metarule code.
    *
    * The respective lines are commented out and tagged as "; metaruled".
    *
    * Make sure all your changes to files are committed to git beforehand,
    * as this modifies files in place.
    *
    * Afterwards, you need to manually look through the changes and remove the
    * redundant code.
    */
  def checkRedundantRul2(): Unit = {
    val seen = collection.mutable.Set.empty[EquivRule]

    // first cache all the RUL2 code generated by metarules
    LOGGER.info("caching RUL2 code generated by metarules")
    Files.list(Paths.get("target")).forEach { path =>
      if (isRulFile(path) && isMetaruleFile(path)) {
        for (scanner <- managed(new java.util.Scanner(path.toFile(), "UTF-8"))) {
          while(scanner.hasNextLine()) {
            parseRule(scanner.nextLine()).foreach { rule =>
              seen.add(new EquivRule(rule))
            }
          }
        }
      }
    }

    // then check handwritten RUL2 code for redundancies
    LOGGER.info("searching for redundant handwritten RUL2 code")
    Files.walk(Paths.get("Controller/RUL2")).forEach { path =>
      if (isRulFile(path) && !isMetaruleFile(path)) {
        val tmpPath = path.resolveSibling(path.getFileName().toString() + ".tmp")
        val endsWithNewline = fileEndsWithNewline(path)  // attempt to preserve missing newlines at end of files to avoid noise
        for (scanner <- managed(new java.util.Scanner(path.toFile(), "UTF-8")); printer <- managed(new java.io.PrintWriter(tmpPath.toFile(), "UTF-8"))) {
          while (scanner.hasNextLine()) {
            val line = scanner.nextLine()
            val printFun: String => Unit = if (!endsWithNewline && !scanner.hasNextLine()) printer.print else printer.println  // preserve missing newlines at end of file
            if (parseRule(line).exists(rule => seen(new EquivRule(rule)))) {
              printFun(s";$line; metaruled")  // comments out the line
            } else {
              printFun(line)
            }
          }
        }
        Files.move(tmpPath, path, java.nio.file.StandardCopyOption.REPLACE_EXISTING)
      }
    }
  }

  // Choose here the metarule-generated code that the handwritten RUL2 code
  // should be compared to.
  val metaruleFiles = Set("Sec7h0_OnslopeMetaGenerated_MANAGED.txt")

  def isMetaruleFile(path: Path): Boolean = {
    metaruleFiles.contains(path.getFileName().toString())
  }

  def isRulFile(path: Path) = {
    val s = path.getFileName().toString()
    s.endsWith(".txt") || s.endsWith(".rul")
  }

  def parseRule(line: String): Option[Rule[IdTile]] = {
    val chunk = line.split(";|\\[", 2)(0).trim
    if (chunk.isEmpty) {
      None
    } else try {
      val ts = chunk.split(",|=").grouped(3).toSeq.map(tup =>
        IdTile(java.lang.Long.decode(tup(0)).toInt, RotFlip(tup(1).toInt, tup(2).toInt)))
      Some(Rule(ts(0), ts(1), ts(2), ts(3)))
    } catch {
      case _: IllegalArgumentException =>  // syntax errors in RUL2 code
        // throw new IllegalArgumentException(line)
        None
    }
  }

  def fileEndsWithNewline(path: Path): Boolean = {
    managed(new java.io.RandomAccessFile(path.toFile(), "r")) acquireAndGet { raf =>
      val size = Files.size(path)
      if (size > 0) {
        raf.seek(size - 1)
        val bytes = Array[Byte](0)
        raf.read(bytes)
        bytes(0) == 0x0a || bytes(0) == 0x0d  // last byte matches \n or \r (assuming last character is ASCII)
      } else {  // size == 0
        false
      }
    }
  }
}
